import random
width = 12
height = 8
starting_coords = (1,0)
steps = [(1,0),(-1,0),(0,1),(0,-1)]
lenght = 34
pregenerated_step_list =[0, 2, 2, 3, 3, 1, 1, 0, 3, 2, 3, 3, 2, 2, 3, 3, 3, 1, 1, 3, 3, 3, 2, 2, 0, 3, 3, 2, 1, 3, 0, 3, 2, 1]

def possible_steps(location:tuple):
    return [(location[0]+a,location[1]+b) for (a,b) in steps]

def check_step(location:tuple, path):
    """Checks if the location is available: checks all neighbours of the desired position."""
    x,y = location
    if not (0 <= x <= width and 0 <= y <= height):
        return False
    sosedje = set((x+a,y+b) for (a,b) in steps)
    if len(set(path).intersection(sosedje))>1:
        return False
    return True

def read(strg):
    """Read string generated by the generate() function, or any other number in 10-digit string format."""
    l = int(strg[:2])
    h = int(strg[2:4])
    c = int(strg[4])
    unique_identifier = int(strg[5:])
    return (l,h,c, unique_identifier)

def sum_1(strg):
    """Sums first 3 digits"""
    sum = 0
    for i in strg[:3]:
        sum += int(i)
    if sum == 0:
        sum = 1
    return sum

def sum_2(strg):
    """Sums last 3 digits"""
    sum = 0
    for i in strg[3:]:
        sum += int(i)
    if sum == 0:
        sum = 1
    return sum

def start_and_end(coords:tuple):
    """Calculate starting and ending coordinates based on unique identifier"""
    if coords[3] % 4 == 0: #na vrhu, na desni
        starting_x, starting_y = coords[0] // sum_1(str(coords[3])), 0
        ending_x, ending_y = coords[0]-1, (coords[1]-1)// sum_2(str(coords[3]))
    elif coords[3] % 4 == 1: #na levi, na desni
        starting_x, starting_y = 0, coords[1] // sum_1(str(coords[3]))
        ending_x, ending_y = coords[0]-1, (coords[1]-1) // sum_2(str(coords[3]))
    elif coords[3] % 4 == 2: #na vrhu, na podnu
        starting_x, starting_y = coords[0] // sum_1(str(coords[3])), 0
        ending_x, ending_y = (coords[0]-1) // sum_2(str(coords[3])),coords[1]-1
    elif coords[3] % 4 == 3: #na levi, na podnu
        starting_x, starting_y = 0, coords[1] // sum_1(str(coords[3]))
        ending_x, ending_y = (coords[0]-1) // sum_2(str(coords[3])), coords[1]-1
    return starting_x,starting_y,ending_x,ending_y


def take_step(location:tuple, width, height):
    pos_steps = possible_steps(location).copy()
    while pos_steps:
        step = random.choice(pos_steps)
        if 0 <= step[0] <= width and 0 <= step[1] <= height:
            x,y = step[0],step[1]
            break
        else:
            pos_steps.remove(step)
    return (x,y)

def draw_map(init_coords:tuple, width:int, height: int):
    x,y= init_coords
    matrix_dict = {}
    matrix=[]
    for _ in range(lenght):
        matrix_dict[(x,y)] = 1
        x,y=take_step((x,y), width, height)
    for j in range(height):
        row = []
        for i in range(width):
            if (i,j) in matrix_dict:
                row.append(1)
            else:
                row.append(0)
        matrix.append(row)
    return matrix

map = draw_map((1,0),15,8)
for row in map:
    print(row)

