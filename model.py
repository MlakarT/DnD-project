#osrednja backend koda za randomizer
#avtor: Timotej Mlakar, MAT-1, Fakulteta za matematiko in fiziko, Univerza v Ljubljani
#Te komentarje sem ze miljonkrat napisal, tako da jih samo kopiram:
#       This is the beginning of the D&D map project. Author: Timotej Mlakar
#       This code will be based first on a current map im working on, later to be expanded (like use input) and submitted as school work.
#       If i choose to add anything, more at https://github.com/MlakarT/DnD-project
#       For any issues or questions please contact me at timo.mlakar@gmail.com or at my university email tm2012@student.uni-lj.si
#       The program will use Pygame for drawing purposes
#Github page bo isti, samo repozitorij bo nov, ta v trenutnem linku bo bodisi preimenovan in arhiviran ali pa odstranjen.
#Z gitom se pocaka do naslednjega tedna, ko bomo imeli le tega na predavanju
# https://www.delftstack.com/howto/python/read-pdf-in-python/ za kasnejso implementacijo branja character sheetov
#more info on this at https://en.wikipedia.org/wiki/Linear_congruential_generator
#aswell as for the two generators used specifically:
#Numerical Recipies generator: https://en.wikipedia.org/wiki/Numerical_Recipes
#Virtual Pascal generator: https://en.wikipedia.org/wiki/Virtual_Pascal
#for the purposes of the matrix generation, the Numerical Recipies generator was used. 
from ast import excepthandler
import random as rd
import time

from numpy import take

#stuff to do with the linear congruetal generator and pseudo-randomness

class Linear_congruetal_generator():
    @staticmethod   
    def lcg(modulus: int, a: int, c: int, seed: int): # Main generator, different miltupliers and increments used below
        while True:
            seed = (a * seed + c) % modulus
            yield seed
    
    @staticmethod   
    def num_rec_lcg(seed:int):
        return Linear_congruetal_generator.lcg(2 ** 32, 1664525,1013904223, seed)

    @staticmethod   
    def virt_pascal_lcg(seed:int):
        return Linear_congruetal_generator.lcg( 2 ** 32, 134775813, 1, seed)

    @staticmethod   
    def read(strg): #code copied from map.py
        x = int(strg[:2])
        y = int(strg[2:4])
        c1 = int(strg[4])
        unique_identifier = int(strg[5:])
        return (x,y,c1, unique_identifier)

    @staticmethod   
    def lcg_read(generated_number:int):
        generated_string = str(generated_number).zfill(10)
        return read(generated_string)

# Code for anything to do with the map, seed, seed generating, seed reading and map generating
def generate():
    """Generate a 10 digit string"""
    l = str(rd.randint(5,50))
    l = l.zfill(2)
    h = str(rd.randint(2,50))
    h = h.zfill(2)
    z = str(rd.randint(1,5))
    unique_identifier = str(rd.randint(0,99999))
    unique_identifier = unique_identifier.zfill(5)
    return l + h + z + unique_identifier

    #return str(rd.randint(0,50)) + str(rd.randint(0,50)) + str(rd.randint(0,5)) + str(rd.randint(0,99999))

def read(strg):
    """Read string generated by the generate() function, or any other number in 10-digit string format."""
    l = int(strg[:2])
    h = int(strg[2:4])
    c = int(strg[4])
    unique_identifier = int(strg[5:])
    return (l,h,c, unique_identifier)

def sum_1(strg):
    """Sums first 3 digits"""
    sum = 0
    for i in strg[:3]:
        sum += int(i)
    if sum == 0:
        sum = 1
    return sum

def sum_2(strg):
    """Sums last 3 digits"""
    sum = 0
    for i in strg[3:]:
        sum += int(i)
    if sum == 0:
        sum = 1
    return sum

def start_and_end(coords:tuple):
    """Calculate starting and ending coordinates based on unique identifier"""
    if coords[3] % 4 == 0: #na vrhu, na desni
        starting_x, starting_y = coords[0] // sum_1(str(coords[3])), 0
        ending_x, ending_y = coords[0]-1, (coords[1]-1)// sum_2(str(coords[3]))
    elif coords[3] % 4 == 1: #na levi, na desni
        starting_x, starting_y = 0, coords[1] // sum_1(str(coords[3]))
        ending_x, ending_y = coords[0]-1, (coords[1]-1) // sum_2(str(coords[3]))
    elif coords[3] % 4 == 2: #na vrhu, na podnu
        starting_x, starting_y = coords[0] // sum_1(str(coords[3])), 0
        ending_x, ending_y = (coords[0]-1) // sum_2(str(coords[3])),coords[1]-1
    elif coords[3] % 4 == 3: #na levi, na podnu
        starting_x, starting_y = 0, coords[1] // sum_1(str(coords[3]))
        ending_x, ending_y = (coords[0]-1) // sum_2(str(coords[3])), coords[1]-1
    return starting_x,starting_y,ending_x,ending_y



#test_lcg1 = lcg(2 ** 32,1664525,1013904223,int(generate())) #testing lcg type NUMERICAL RECIPIES at https://en.wikipedia.org/wiki/Numerical_Recipes
#test_lcg2 = lcg(2 ** 32, 134775813, 1, int(generate())) at https://en.wikipedia.org/wiki/Virtual_Pascal
#print([next(test_lcg1) for i in range(20)])
#print([next(test_lcg2) for i in range(20)])

class Map:
    def __init__(self,seed_str:str):
        self.seed = seed_str
        self.dimensions = read(self.seed)
        self.x, self.y, self.complexity, self.unique_identifier = self.dimensions[0],self.dimensions[1], self.dimensions[2], str(self.dimensions[3])
        self.length = self.x + self.y -1
        for i in self.unique_identifier:
            self.length += int(i)
        self. length = self.length * self.complexity
        self.lcg = Linear_congruetal_generator.num_rec_lcg(int(self.seed))
        self.lcg_list = [next(self.lcg) for _ in range(self.length)]
        self.step_list = [(i % int(self.unique_identifier)) % 4 for i in self.lcg_list]
        self.start_x, self.start_y, self.end_x, self.end_y = start_and_end(self.dimensions)
        self.starting_coords = self.start_x, self.start_y
        self.finish_coords = self.end_x, self.end_y
        #print(self.seed, self.dimensions, self.length)

    def __repr__(self) -> str:
        return f"map object"

    def __str__(self) -> str:
        return f"{self.dimensions}"

    @staticmethod
    def take_step(location:tuple ,step:int):
        """Takes provided step regardless of condition"""
        x,y = location
        if step == 0:
            new_location = (x+1,y)
        elif step == 1:
            new_location = (x,y+1)
        elif step == 2:
            new_location = (x-1,y)
        elif step == 3:
            new_location = (x,y-1)
        return new_location

    @staticmethod
    def check_sq(exception_dict:dict, location:tuple) -> bool:
        """Checks if any squares have been placed in or directly next to the spot, where the step is trying to place the square"""
        x,y = location
        total_faults = 0
        if (x+1,y) in exception_dict:
            total_faults += 1
        if (x-1,y) in exception_dict:
            total_faults += 1
        if (x,y+1) in exception_dict:
                    total_faults += 1
        if (x,y-1) in exception_dict:
                    total_faults += 1
        return total_faults <= 1

    @staticmethod
    def try_directions(exception_dict:dict, location:tuple, step:int):
        """Step variable indicated attempted step"""
        x,y = location
        if step == 0 or step == 2:
            if Map.check_sq(exception_dict, (x,y+1)): #check if you can go up first
                return Map.take_step ((x,y), 1)
            elif Map.check_sq(exception_dict, (x,y-1)): #then check if you can go down
                return Map.take_step((x,y),3)
            else:
                return "Fatal error, check code"
        elif step == 1 or step == 3:
            if Map.check_sq(exception_dict, (x+1,y)):
                return Map.take_step((x,y),0)
            elif Map.check_sq(exception_dict, (x-1,y)):
                return Map.take_step((x,y),2)
            else: return "Fatal error, check code"
    


    def exception_library(self):
        """Creates the positions of ones in the matrix"""
        self.exceptions = {}
        self.exceptions[self.starting_coords] = 2
        self.exceptions[self.finish_coords] = 2
        x_s, y_s = self.starting_coords
        k = 2
        while k <= self.length:
            for step in self.step_list:
                # x_s, y_s = take_step((x_s,y_s), step)
                # self.exceptions[(x_s,y_s)] = 1
                # k += 1
                if step == 0:
                    if Map.check_sq(self.exceptions,(x_s+1,y_s)):
                        x_s,y_s = Map.take_step((x_s,y_s),0)
                        self.exceptions[(x_s,y_s)] = 1
                        k+=1
                    else:
                        x_s,y_s = Map.try_directions(self.exceptions, (x_s,y_s),0)
                        self.exceptions[(x_s,y_s)] = 1
                        k+=1
                elif step == 1:
                    if Map.check_sq(self.exceptions,(x_s,y_s+1)):
                        x_s,y_s = Map.take_step((x_s,y_s),1)
                        self.exceptions[(x_s,y_s)] = 1
                        k+=1
                    else:
                        x_s,y_s = Map.try_directions(self.exceptions, (x_s,y_s),1)
                        self.exceptions[(x_s,y_s)] = 1
                        k+=1              
                elif step == 2:
                    if Map.check_sq(self.exceptions,(x_s-1,y_s)):
                        x_s,y_s = Map.take_step((x_s,y_s),2)
                        self.exceptions[(x_s,y_s)] = 1
                        k+=1
                    else:
                        x_s,y_s = Map.try_directions(self.exceptions, (x_s,y_s),2)
                        self.exceptions[(x_s,y_s)] = 1
                        k+=1               
                elif step == 3:
                    if Map.check_sq(self.exceptions,(x_s,y_s-1)):
                        x_s,y_s = Map.take_step((x_s,y_s),3)
                        self.exceptions[(x_s,y_s)] = 1
                        k+=1
                    else:
                        x_s,y_s = Map.try_directions(self.exceptions, (x_s,y_s),3)
                        self.exceptions[(x_s,y_s)] = 1
                        k+=1              
                else:
                    return "something went wrong" 

        #this will change more, will be adjusted later
        #This fucker right here can fuck right the fuck off fuckin g piece of shit fuck shit
        #return self.exceptions

    def grid_matrix(self):
        """Creates the grid matrix"""
        matrix = []
        for i in range(self.y):
            row = []
            for j in range(self.x):
                if (j,i) in self.exceptions:
                    row.append(self.exceptions[(j,i)])
                else:
                    row.append(0)
            #print(row)
            matrix.append(row)
        self.matrix = matrix.copy()

#done
# Code for anything to do with the dice


class Dice():
    """Prejme število in ustvari n-strano kocko."""
    def __init__(self,dice:int):
        self.sides = dice
        self.all_rolls = []

    def __repr__(self) -> str:
        return f'Dice({self.sides})'

    def __str__(self) -> str:
        return f'd{self.sides}'
        
    #This one should be in the front end code, will be moved later.
    @staticmethod
    def random_numbers(num:int, secs:float=1, interval:float=0.1):
        """Shows random numbers in the range of the dice rolled, every @interval seconds for @secs seconds."""
        time_end = time.time() + secs
        while time.time() < time_end:
            print(rd.randint(1,num))
            time.sleep(interval)

    @staticmethod
    def roll(sides:int,num_off_rolls:int =1):
        """Rolls @sides sided dice @num_of_rolls times, with @time_between_rolls seconds passing between each roll. Prints out the numbers."""
        i = 1
        rolls = []
        while i <= num_off_rolls:
            rolled = rd.randint(1,sides)
            rolls.append(rolled)
            i += 1
        return rolls

    @staticmethod
    def simulate_roll(sides:int,rolls:list,time_between_rolls:int=0.5):
        i = 1
        while i <= len(rolls):
            print('Rolling...')
            Dice.random_numbers(sides,0.5)
            rolled = rolls[i-1]
            print('Rolled:', rolled)
            if i != len(rolls):
                time.sleep(time_between_rolls)
            i += 1
    def __call__(self,num_of_rolls:int =1, time_between_rolls:int=0.5):
        """Call na kocko vrže kocko @num_of_rolls krat, vmes počaka @time_between_rolls sekund."""
        rolls = Dice.roll(self.sides, num_of_rolls)
        self.all_rolls.extend(rolls)
        return Dice.simulate_roll(self.sides, rolls, time_between_rolls)

    def fast_roll(self,num_of_rolls:int=1):
        """Naredi podobno, le da samo naprinta vržene vrednosti."""
        i = 1
        rolls = []
        while i <= num_of_rolls:
            rolls.append(rd.randint(1,self.sides))
            i += 1
        self.all_rolls.extend(rolls)
        for i in rolls:
            print('Rolled:', i)

    def roll_history(self):
        return self.all_rolls if self.all_rolls else 'No history'


MAP1 = Map('1209112345')
print(MAP1.seed, MAP1.x, MAP1.y, MAP1.length, MAP1.starting_coords, MAP1.finish_coords, MAP1.step_list)
MAP1.exception_library()
print( MAP1.exceptions)
MAP1.grid_matrix()
for row in MAP1.matrix:
    print (row)

STANDARDNI_SET = {'d100' : Dice(100),
        'd20': Dice(20),
        'd12': Dice(12),
        'd10': Dice(10),
        'd8': Dice(8),
        'd6': Dice(6),
        'd4': Dice(4),
        'd3': Dice(3),
        'd2': Dice(2)}